<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>

<!--#include file="Head.html"-->

<body bgcolor="#FFFFFF" leftmargin=0 topmargin=0 text="black" link="#0000FF" 
vlink="#000000" alink="#000000">

<!--#include file="Table.html"-->

<tr>
<!--#include file="SideBar.html"-->

    <td width="550" valign="top" bgcolor="#FFFFFF">
    <div align="left">
    <font size=3>Frequently </font> asked questions are listed here with
    answers:

    <ol>
      <li><b>Does GCC-XML work with pure C code too?</b><br>
        Yes and no.  GCC-XML is written as an extension to GCC's C++ parser
        and therefore treats all source files as C++ regardless of their
        extension.  If the C code happens to be valid C++ then GCC-XML
        will handle it.  There are a few parts of C not included in C++
        that will cause GCC-XML to produce errors.  These are documented
        in Annex C of the C++98 Standard.

      <li><b>Why are C++ function bodies not dumped in XML?</b><br>
        The original <a href="Sponsors.html">sponsors</a> of the
        project had no need for function bodies.  So far the authors
        have not had time or funding to implement the support.
        Contact the mailing list if you are interested in contributing
        this support or providing funding to have it implemented.

      <li><b>Is there a DTD specifying the XML format dumped?</b><br>

        Not currently.  Several hand-written DTDs have been posted to
        the mailing list and can be found in the archives.  However,
        there will not be an official DTD until it can be
        automatically generated by the gccxml executable.  When such
        functionality is implemented, it will be integrated with the
        XML dump code itself and therefore easy to maintain.

      <li><b>Why are most classes, structs, and
             enums marked as "artificial"?</b><br>

        The <code>artificial</code> attribute marks nodes that are artificially
        generated by the compiler (such as implicit copy constructors).
        The C++ code
        <blockquote>
          <code>
            struct foo {};
          </code>
        </blockquote>
        is almost the same as the C code
        <blockquote>
          <code>
            struct foo {};<br>
            typedef struct foo foo;
          </code>
        </blockquote>
        because the C++ compiler adds the typedef artificially.
        The name <code>foo</code> for the struct shown above is reported as the
        name in the <code>Struct</code> element in the XML output, but this name
        was artifically generated so that programmers would not have
        to write <code>struct foo</code>.

      <li><b>Why don't I see templates in the output?</b><br>

        This feature has not been implemented because the driving project
        for which GCC-XML was written had no need for uninstantiated
        templates.  Template instantiations will still be dumped, though.
        For example:
        <blockquote>
          <code>
            template &lt;class T&gt; struct foo {};<br>
            typedef foo&lt;int&gt;::foo foo_int;
          </code>
        </blockquote>
        will instantiate <code>foo&lt;int&gt;</code>, which will be included
        in the output.  However, there will be no place that explicitly
        lists the set of types used for the instantiation other than in
        the name.  This is because the proper way to do it is to dump the
        templates too and reference them from the instantiations with
        the template arguments listed.  Since the features will be linked
        they should be implemented together.

    </ol>
    </div>
    </td>
</tr>

</table>

</td>
</tr>
</table>

</body>
</html>
